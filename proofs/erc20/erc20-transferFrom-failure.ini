[DEFAULT]

k: #execute => #exception

callData: #abiCallData("transferFrom", #address(FROM_ID), #address(TO_ID), #uint256(VALUE))

localMem:
    .Map => _:Map

gas:
    /* G */ 100000 => _

log:
    /* _ */ .List

refund:
    /* _ */ 0 => _ /* TODO: more detail */

epilogue:
    // TODO: properly consider exception preserving the input status
    //       using CALL GCAP ACCTTO VALUE ARGSTART ARGWIDTH RETSTART RETWIDTH

    // NOTE: negative VALUE is not possible since it is of `num256` type

[1a]

storage:
    sha3(0) +Word FROM_ID |-> (BAL_FROM => _)  // BAL_FROM
    sha3(0) +Word TO_ID   |-> (BAL_TO   => _)  // BAL_TO  
    sha3(sha3(1) +Word FROM_ID) +Word CALLER_ID |-> ALLOW
    _:Map

requires:
    andBool 0 <=Int FROM_ID   andBool FROM_ID   <Int (2 ^Int 160)
    andBool 0 <=Int TO_ID     andBool TO_ID     <Int (2 ^Int 160)
    andBool 0 <=Int VALUE     andBool VALUE     <Int (2 ^Int 256)
    andBool 0 <=Int BAL_FROM  andBool BAL_FROM  <Int (2 ^Int 256)
    andBool 0 <=Int BAL_TO    andBool BAL_TO    <Int (2 ^Int 256)
    andBool 0 <=Int ALLOW     andBool ALLOW     <Int (2 ^Int 256)
    andBool FROM_ID =/=Int TO_ID
    andBool VALUE >Int BAL_FROM
  //andBool BAL_TO +Int VALUE >=Int (2 ^Int 256) // viper overflow check: ( VALUE =/=Int 0 andBool BAL_TO +Word VALUE <Int BAL_TO )
  //andBool VALUE >Int ALLOW

[1b]

storage:
    sha3(0) +Word FROM_ID |-> (BAL_FROM => _)  // BAL_FROM  or  BAL_FROM -Int VALUE
    sha3(0) +Word TO_ID   |-> (BAL_TO   => _)  // BAL_TO
    sha3(sha3(1) +Word FROM_ID) +Word CALLER_ID |-> ALLOW
    _:Map

requires:
    andBool 0 <=Int FROM_ID   andBool FROM_ID   <Int (2 ^Int 160)
    andBool 0 <=Int TO_ID     andBool TO_ID     <Int (2 ^Int 160)
    andBool 0 <=Int VALUE     andBool VALUE     <Int (2 ^Int 256)
    andBool 0 <=Int BAL_FROM  andBool BAL_FROM  <Int (2 ^Int 256)
    andBool 0 <=Int BAL_TO    andBool BAL_TO    <Int (2 ^Int 256)
    andBool 0 <=Int ALLOW     andBool ALLOW     <Int (2 ^Int 256)
    andBool FROM_ID =/=Int TO_ID
  //andBool VALUE >Int BAL_FROM
    andBool BAL_TO +Int VALUE >=Int (2 ^Int 256) // viper overflow check: ( VALUE =/=Int 0 andBool BAL_TO +Word VALUE <Int BAL_TO )
  //andBool VALUE >Int ALLOW

[1c]

storage:
    sha3(0) +Word FROM_ID |-> (BAL_FROM => _)  // BAL_FROM  or  BAL_FROM -Int VALUE
    sha3(0) +Word TO_ID   |-> (BAL_TO   => _)  // BAL_TO    or  BAL_TO   +Int VALUE
    sha3(sha3(1) +Word FROM_ID) +Word CALLER_ID |-> ALLOW
    _:Map

requires:
    andBool 0 <=Int FROM_ID   andBool FROM_ID   <Int (2 ^Int 160)
    andBool 0 <=Int TO_ID     andBool TO_ID     <Int (2 ^Int 160)
    andBool 0 <=Int VALUE     andBool VALUE     <Int (2 ^Int 256)
    andBool 0 <=Int BAL_FROM  andBool BAL_FROM  <Int (2 ^Int 256)
    andBool 0 <=Int BAL_TO    andBool BAL_TO    <Int (2 ^Int 256)
    andBool 0 <=Int ALLOW     andBool ALLOW     <Int (2 ^Int 256)
    andBool FROM_ID =/=Int TO_ID
  //andBool VALUE >Int BAL_FROM
  //andBool BAL_TO +Int VALUE >=Int (2 ^Int 256) // viper overflow check: ( VALUE =/=Int 0 andBool BAL_TO +Word VALUE <Int BAL_TO )
    andBool VALUE >Int ALLOW

[2]

storage:
    sha3(0) +Word FROM_ID |-> BAL_FROM
    sha3(sha3(1) +Word FROM_ID) +Word CALLER_ID |-> ALLOW
    _:Map

requires:
    andBool 0 <=Int FROM_ID   andBool FROM_ID   <Int (2 ^Int 160)
    andBool 0 <=Int TO_ID     andBool TO_ID     <Int (2 ^Int 160)
    andBool 0 <=Int VALUE     andBool VALUE     <Int (2 ^Int 256)
    andBool 0 <=Int BAL_FROM  andBool BAL_FROM  <Int (2 ^Int 256)
    andBool 0 <=Int ALLOW     andBool ALLOW     <Int (2 ^Int 256)
    andBool FROM_ID ==Int TO_ID
    andBool ( VALUE >Int BAL_FROM
     orBool   VALUE >Int ALLOW )
