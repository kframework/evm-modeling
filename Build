#!/usr/bin/env bash

set -e      # Exit immediately if any command fails

analysis_dir="tests/analysis/"
tests_dir="tests/VMTests/"
expected_passing="tests/passing.expected"
long_running="tests/long-running"
now_passing="tests/passing.lastrun"

export cMODE=${cMODE:-VMTESTS}
export cSCHEDULE=${cSCHEDULE:-DEFAULT}

krun_with_opts() {
    krun --directory .build/$K_VERSION/ --debug -cMODE=$cMODE -cSCHEDULE=$cSCHEDULE $@
}

progress() { echo "== $@"; }
success()  { echo -e "\e[32m== success: $@\e[0m";
             echo "$@" >> "$now_passing"
           }
failure()  { echo -e "\e[31m== failure: $@\e[0m"; }

list_analysis()   { find "$analysis_dir" -wholename "*$exp*" -name '*.evm'; }
list_tests()      { find "$tests_dir" -wholename "*$exp*" -name '*.json'; }
list_passing()    { cat "$expected_passing"; }
list_failing()    { list_tests | grep -Fvxf "$expected_passing" -; }
list_quicktests() { list_passing | filter_not_longrunning | sort -R | head -n 20; }
list_codeship()   { list_passing | filter_codeship "$1"; }

filter_not_longrunning() { grep -Fvxf "$long_running" -; }

filter_codeship() {
    codeship_list="$1"
    case "$codeship_list" in
        1)  grep -e 'vmArithmeticTest/[a-dA-D]'                                                ;;
        2)  grep -e 'vmArithmeticTest/expPowerOf256Of256'                                      ;;
        3)  grep -e 'vmArithmeticTest/[eE]' | grep -v -e 'vmArithmeticTest/expPowerOf256Of256' ;;
        4)  grep -e 'vmArithmeticTest/[f-mF-M]'                                                ;;
        5)  grep -e 'vmArithmeticTest/[n-zN-Z]'                                                ;;
        6)  grep -e 'vmBitwiseLogicOperationTest'                                              ;;
        7)  grep -e 'vmBlockInfoTest' -e 'vmEnvironmentalInfoTest/[a-bA-B]'                    ;;
        8)  grep -e 'vmEnvironmentalInfoTest/[cC]'                                             ;;
        9)  grep -e 'vmEnvironmentalInfoTest/[d-zD-Z]' -e 'vmIOandFlowOperationsTest/[a-iA-B]' ;;
        10) grep -e 'vmIOandFlowOperationsTest/[C-I]'                                          ;;
        11) grep -e 'vmIOandFlowOperationsTest/[j]'                                            ;;
        12) grep -e 'vmIOandFlowOperationsTest/[J]'                                            ;;
        13) grep -e 'vmIOandFlowOperationsTest/[k-mK-M]'                                       ;;
        14) grep -e 'vmIOandFlowOperationsTest/[n-zN-Z]'                                       ;;
        15) grep -e 'vmLogTest/log[0-2]' -e 'vmLogTest/log_'                                   ;;
        16) grep -e 'vmLogTest/log[3-9]'                                                       ;;
        17) grep -e 'vmPerformanceTest' -e 'vmPushDupSwapTest/[a-oA-O]'                        ;;
        18) grep -e 'vmPushDupSwapTest/push[0-1]'                                              ;;
        19) grep -e 'vmPushDupSwapTest/[q-zQ-Z]' -e 'vmPushDupSwapTest/push[2-9]'              ;;
        20) grep -e 'vmSystemOperationsTest' -e 'vmSha3Test' -e 'vmtests'                      ;;
    esac | filter_not_longrunning
}

pretty_diff() {
    if type colordiff >/dev/null 2>&1; then
        colordiff -u "$@"
    else
        diff -u "$@"
    fi
}

# Reads a list of json test files from stdin, and runs them
run_tests() {
    local test_file test_fail_count=0
    while read test_file; do
        let test_count="$test_count + 1"
        local output_differs=false
        progress "running: $test_file..."
        pretty_diff \
            --label expected <(cat "$output_file" | lint_krun) \
            --label actual   <(krun_with_opts "$test_file" | lint_krun) \
            || output_differs=true
        if $output_differs; then
            failure "$test_file"
            let test_fail_count="$test_fail_count + 1"
        else
            success "$test_file"
        fi
        progress "failed: $test_fail_count / $test_count"
    done
    return $test_fail_count
}

filter_tests() {
    local command=( exit 1 )
    case $# in
    0) cat;       return ;;
    1) grep "$1"; return ;;
    *) cat > /dev/null;
       echo >&2 "Too many expressions";
       ;;
    esac
}

lint_krun() {
    # Format, &gt; entity > and make each K task start on a new line
    xmllint -format - | sed -e 's/&gt;/>/g'  -e 's/~>/\n   ~>/g'
}

run_krun() {
    run_make all
    while read test_file; do
        progress "running: $test_file"
        krun_with_opts "$test_file" | lint_krun
    done
}

check_for_tangle() {
    type pandoc-tangle >/dev/null 2>&1  || {
        have_tangle=false
        echo -e >&2 "Warning: pandoc-tangle not installed."  \
                   "Ignoring changes in markdown files\n"
    }
}

run_make() {
    local make_opts=
    $have_tangle || make_opts="--assume-old ethereum.md --assume-old evm.md \
                               --assume-old data.md --assume-old krypto.md"
    make K_VERSION=${K_VERSION} -s $make_opts $@
}

test_pipe_line() {
    local list=$1; shift
    local do_run=$1; shift;

    run_make all
    $list | filter_tests "$@" | $do_run; exit
}

run_debug() {
    list="$1" && shift
    run_make all
    file=$(test_pipe_line $list cat "$@" | head -n 1)
    progress "debugging: $file"
    krun_with_opts --debugger "$file"
    exit
}


######################################################################
## Main

if krun --version | grep 'RV' >/dev/null 2>&1; then
    K_VERSION=rvk
else
    K_VERSION=uiuck
fi
progress "Using $K_VERSION"

output_file="tests/templates/output-$K_VERSION.txt"
have_tangle=true; check_for_tangle

[[ "$#" == '0' ]] && set build
run_command="$1" && shift
case "$run_command" in

    # Building
    build)         run_make build ;;
    defn)          run_make defn ;;

    # Running
    krun)          test_pipe_line list_tests run_krun "$@" ;;
    debug)         run_debug list_analysis "$@" ;;
    analyze-gas)   export cMODE=GASANALYZE ; test_pipe_line list_analysis run_krun "$@" ;;
    analyze-debug) export cMODE=GASANALYZE ; run_debug list_analysis "$@" ;;

    # Test lists
    list-tests)    test_pipe_line list_tests   cat "$@" ;;
    list-passing)  test_pipe_line list_passing cat "$@" ;;
    list-failing)  test_pipe_line list_failing cat "$@" ;;
    list-codeship) test_pipe_line list_codeship cat "$@" ;;
    list-analysis) test_pipe_line list_analysis cat "$@" ;;

    # Test runs
    test)          test_pipe_line list_tests     run_tests "$@" ;;
    passing)       test_pipe_line list_passing   run_tests "$@" ;;
    failing)       test_pipe_line list_failing   run_tests "$@" ;;
    codeship)      test_pipe_line list_codeship  run_tests "$@" ;;
    quicktest)     test_pipe_line list_quicktests run_tests "$@" ;;

    *)             echo "
    usage:
       $0                       Build the definitions and kompile them

       $0 build                 Detangle the definitions and kompile
       $0 defn                  Only detangle the definitions

       $0 krun                  Run a single program from the tests
       $0 debug                 Debug a single program from the tests
       $0 analyze-gas           Analyze a single program from the analysis directory
       $0 analyze-debug         Debug a single program from the analysis directory

       $0 list-tests   <regx>   List passing and failing tests
       $0 list-failing <regx>   List failing tests
       $0 list-passing <regx>   List passing tests
       $0 list-codeship N       List the Nth codeship testsuite

       $0 test    <regx>        Run passing and unknown tests
       $0 passing <regx>        Run known passing tests
       $0 failing <regx>        Run tests who's results we're not sure of
       $0 codeship N            Run the Nth codeship testsuite
       $0 quicktest             Run 20 random passing tests
"; exit ;;
esac
