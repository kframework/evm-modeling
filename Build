#!/usr/bin/env bash

set -e      # Exit immediately if any command fails
set -u      # Using undefined variables is an error. Exit immediately

# Utilities
# ---------

progress() { echo "== $@"; }
warning()  { echo -e "WARNING:" "$@"; }
die()      { echo -e "FATAL:" "$@"; exit 1; }

success()  { echo -e "\e[32m== success: $@\e[0m";
             echo "$@" >> "$now_passing"
           }
failure()  { echo -e "\e[31m== failure: $@\e[0m"; }

pretty_diff() {
    if type colordiff >/dev/null 2>&1; then
        colordiff -u "$@"
    else
        diff -u "$@"
    fi
}

check_for_tangle() {
    type pandoc-tangle >/dev/null 2>&1  || {
        have_tangle=false
        warning "pandoc-tangle not installed."  \
                "Ignoring changes in markdown files\n"
    }
}

lint_krun() {
    # Format, &gt; entity > and make each K task start on a new line
    xmllint -format - | sed -e 's/&gt;/>/g'  -e 's/~>/\n   ~>/g'
}

set_test_opts_for_proofs() {
    proof_file="$1"
    local basename="$(basename -s -spec.k "$1")"
    local basepath="$(dirname "$1")/$basename"
    test_opts=( -cMODE=NORMAL "proofs/dummy-input.json" --prove "$proof_file-spec.k" )
}

# Test Filters and Lists
# ----------------------

filter_not_longrunning() { grep -Fvxf "tests/long-running" - ; }
filter_tests() {
    local command=( exit 1 )
    case $# in
    0) cat;       return ;;
    1) grep "$1"; return ;;
    *) cat > /dev/null;
       warning "Too many expressions";
       ;;
    esac
}

list_long()  { cat "tests/long-running" ; }
list_short() { cat "tests/short-list"   ; }
test_lists="long short"

list_proofs()       { find "proofs"             -name '*-spec.k' ; }
list_gas_analysis() { find "tests/gas-analysis" -name '*.evm' ; }
list_vmtests()      { find "tests/VMTests"      -name '*.json' | grep -v 'loop_stacklimit_1021' ; }
test_lists="$test_lists proofs gas_analysis vmtests"

list_rvk()   { list_vmtests ; }
list_uiuck() { list_proofs ; list_gas_analysis ; list_short ; }
list_all()   { list_$K_VERSION ; }
list_quick() { list_all | filter_not_longrunning | sort -R | head -n 20 ; }
test_lists="$test_lists rvk uiuck all quick"

# Runners
# -------

run_uiuck() {
    local run_file=$1; shift
    local test_opts=()
    export K_OPTS=-Xss500m
    export cSCHEDULE=${cSCHEDULE:-DEFAULT}
    case "$run_file" in
       *gas-analysis/*) test_opts=( -cMODE=GASANALYZE "$run_file" )           ;;
       *VMTests/*     ) test_opts=( -cMODE=VMTESTS    "$run_file" )           ;;
       *proofs/*      ) set_test_opts_for_proofs "$run_file"                  ;;
       *              ) die "Don't know how to set test_opts for '$run_file'" ;;
    esac
    krun --directory .build/$K_VERSION/ --debug -cSCHEDULE=$cSCHEDULE "${test_opts[@]}" "$@"
}

run_krun() {
    progress "running: $1"
    ( run_uiuck "$1" | lint_krun )
}

run_kdebug() {
    progress "debugging: $1"
    ( run_uiuck "$1" --debugger )
}

run_make() {
    local make_opts=
    $have_tangle || make_opts="--assume-old ethereum.md --assume-old evm.md \
                               --assume-old data.md --assume-old krypto.md"
    [[ "$K_VERSION" == 'rvk' ]] && eval `opam config env`
    make K_VERSION=${K_VERSION} -s $make_opts $@
}


# Testers
# -------

test_uiuck() {
    test_file="$1"
    local output_file="$default_output_file"
    if [[ -e $test_file.out ]]; then output_file=$test_file.out; fi
    ( # Running in a sub-shell to avoid export spilling over to other tests
        pretty_diff --label expected <(cat "$output_file") \
                    --label actual   <(run_uiuck "$test_file" | lint_krun)
    )
}

test_rvk() {
    test_file="$1"
    (
        # TODO: Integrate this into Build nicely
        set +e;
        eval `opam config env`
        interpreter="$(dirname "$0")/.build/rvk/ethereum-kompiled/interpreter"
        kast="$(mktemp)"
        output="$(mktemp)"
        kast_output="$(mktemp)"
        trap "rm -rf $kast $output $kast_output" INT TERM EXIT
        "$(dirname "$0")/kast-json.py" "$test_file" > "$kast"
        $interpreter "$(dirname "$0")/.build/rvk/ethereum-kompiled/realdef.cma" -c PGM "$kast" textfile \
                     -c SCHEDULE '`DEFAULT_ETHEREUM`(.KList)' text -c MODE '`VMTESTS_ETHEREUM`(.KList)' text \
                     --output-file "$output"
        exit=$?
        if [ $exit -eq 0 ]; then
          exit 0
        fi
        k-bin-to-text "$output" "$kast_output"
        cat "$kast_output"
        printf "\n"
        exit $exit
    )
}

run_test() {
    run_make
    "test_$K_VERSION" "$@"
}

run_tests() {
    local test_count=0
    local test_failed=0
    while read test_file; do
        progress "running: $test_file"
        test_count=$(($test_count + 1))
        exit_status=0
        run_test "$test_file" || exit_status=$?
        if [[ $exit_status -eq 0 ]]; then
            success "$test_file"
        else
            failure "$test_file"
            test_failed=$(($test_failed + 1))
        fi
        progress "failed: $test_failed / $test_count"
    done
    return $test_failed
}

run_partests() {
    run_make
    [[ "$K_VERSION" == 'rvk'   ]] && mem_free=1G
    [[ "$K_VERSION" == 'uiuck' ]] && mem_free=2G
    parallel --joblog - --memfree "$mem_free" ./Build test
}

# Experimental
# ------------
hkg_proof_dir=tests/proofs/hkg

build_proofs() {
    mkdir -p $hkg_proof_dir
    progress "tangle: $hkg_proof_dir/transferFrom-then-spec.k"
    pandoc-tangle --from markdown --to code-k --section "Then Branch" proofs/hkg/transferFrom.md > $hkg_proof_dir/transferFrom-then-spec.k
    progress "tangle: $hkg_proof_dir/transferFrom-else-spec.k"
    pandoc-tangle --from markdown --to code-k --section "Else Branch" proofs/hkg/transferFrom.md > $hkg_proof_dir/transferFrom-else-spec.k
}

run_proofs() {
    run_make
    build_proofs
    run_uiuck 'tests/proofs/hkg/transferFrom-then'
    run_uiuck 'tests/proofs/hkg/transferFrom-else'
}

# Main
# ----

cd "$(dirname $0)"

if [[ -z "$K_VERSION" ]]; then
    if krun --version | grep 'RV' >/dev/null 2>&1; then
        K_VERSION=rvk
    else
        K_VERSION=uiuck
    fi
fi
progress "Using $K_VERSION"

default_output_file="tests/templates/output-$K_VERSION.txt"
have_tangle=true; check_for_tangle

test_logs="tests/logs"
mkdir -p "$test_logs"
now_passing="$test_logs/passing.lastrun"
ci_branches=( develop )

[[ "$#" == '0' ]] && set build
run_command="$1" ; shift
case "$run_command" in

    # Building
    defn)  run_make defn ;;
    build) run_make all  ;;

    # Running
    run)   run_krun   "$1" ;;
    test)  run_test   "$1" ;;
    debug) run_kdebug "$1" ;;

    # Testing
    list-*)    list_${run_command#list-}    | filter_tests "$@" ;;
    test-*)    list_${run_command#test-}    | filter_tests "$@" | run_tests    ;;
    partest-*) list_${run_command#partest-} | filter_tests "$@" | run_partests ;;

    # Experimental
    build-proofs) build_proofs ;;
    run-proofs)   run_proofs   ;;

    *)             echo "
    usage:
       $0       Defaults to '$0 build'

       # Building
       # --------
       $0 defn      Only detangle the definitions
       $0 build     Detangle defintions and kompile

       # Running
       # -------
       $0 run   <pgm>   Run a single EVM program
       $0 test  <pgm>   Run a single EVM program like it's a test
       $0 debug <pgm>   Run a single EVM program in the debugger

       # Testing
       # -------
       $0 list-<test-list>    <regx>    List tests from <test-list> filtered by <regx>
       $0 test-<test-list>    <regx>    Run tests from <test-list> filtered by <regx>
       $0 partest-<test-list> <regx>    Run tests from <test-list> filtered by <regx> with GNU parallel

       # Settings
       # --------
       Available <test-list>: $test_lists
       K_VERSION: $K_VERSION
"; exit ;;
esac
