KEVM Optimizations
==================

These optimizations work on the LLVM and Haskell backend and are generated by the script `./optimizer/optimizations.sh`.

```k
requires "evm.md"

module EVM-OPTIMIZATIONS-LEMMAS [kore]
    imports EVM
endmodule

module EVM-OPTIMIZATIONS [kore]
    imports EVM-OPTIMIZATIONS-LEMMAS

    // Nonsense rule to trigger initial slowdown
    rule <k> #halt ~> #halt ~> #halt => . </k> [priority(40)]

rule <kevm>
       <k>
         ( #next[ PUSH(N) ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <program>
               PGM
             </program>
             <wordStack>
               ( WS => #asWord( PGM [ ( PCOUNT +Int 1 ) .. N ] ) : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( ( PCOUNT +Int N ) +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gverylow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Gverylow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( #asWord( PGM [ ( PCOUNT +Int 1 ) .. N ] ) : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ DUP(N) ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( WS => WS [ ( N +Int -1 ) ] : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gverylow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires #stackNeeded(DUP(N)) <=Int #sizeWordStack(WS)
   andBool ( Gverylow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( WS [ ( N +Int -1 ) ] : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ SWAP(N) ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : WS => WS [ ( N +Int -1 ) ] : ( WS [ ( N +Int -1 ) := W0 ] ) )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gverylow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires #stackNeeded(SWAP(N)) <=Int #sizeWordStack(W0 : WS)
   andBool ( Gverylow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( WS [ ( N +Int -1 ) ] : ( WS [ ( N +Int -1 ) := W0 ] ) ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ ADD ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : WS => chop( ( W0 +Int W1 ) ) : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gverylow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Gverylow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( chop( ( W0 +Int W1 ) ) : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ LT ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : WS => bool2Word( W0 <Int W1 ) : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gverylow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Gverylow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( bool2Word( W0 <Int W1 ) : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ POP ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : WS => WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gbase < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Gbase < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ MULMOD ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : W2 : WS => ( W0 *Int W1 ) %Word W2 : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gmid < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Gmid < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( ( W0 *Int W1 ) %Word W2 : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ MSTORE8 ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : WS => WS )
             </wordStack>
             <localMem>
               ( LM => padRightBytes( LM , ( W0 +Int 1 ) , 0 ) [ W0 <- W1 modInt 256 ] )
             </localMem>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int ( ( Cmem( SCHED , #memoryUsageUpdate( MU , W0 , 1 ) ) -Int Cmem( SCHED , MU ) ) +Int Gverylow < SCHED > ) ) )
             </gas>
             <memoryUsed>
               ( MU => #memoryUsageUpdate( MU , W0 , 1 ) )
             </memoryUsed>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( ( ( Cmem( SCHED , #memoryUsageUpdate( MU , W0 , 1 ) ) -Int Cmem( SCHED , MU ) ) +Int Gverylow < SCHED > ) <=Int GAVAIL )
   andBool ( #sizeWordStack( WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ SIGNEXTEND ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : WS => signextend( W0 , W1 ) : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Glow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Glow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( signextend( W0 , W1 ) : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ SGT ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : WS => W1 s<Word W0 : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gverylow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Gverylow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( W1 s<Word W0 : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ SLT ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : WS => W0 s<Word W1 : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gverylow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Gverylow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( W0 s<Word W1 : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ GT ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : WS => bool2Word( W1 <Int W0 ) : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gverylow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Gverylow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( bool2Word( W1 <Int W0 ) : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ EVMOR ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : WS => W0 |Int W1 : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gverylow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Gverylow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( W0 |Int W1 : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ MOD ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : WS => W0 %Word W1 : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Glow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Glow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( W0 %Word W1 : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ SUB ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : WS => chop( ( W0 -Int W1 ) ) : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Gverylow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Gverylow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( chop( ( W0 -Int W1 ) ) : WS ) <=Int 1024 )
    [priority(40)]


rule <kevm>
       <k>
         ( #next[ DIV ] => . ) ...
       </k>
       <schedule>
         SCHED
       </schedule>
       <ethereum>
         <evm>
           <callState>
             <wordStack>
               ( W0 : W1 : WS => W0 /Word W1 : WS )
             </wordStack>
             <pc>
               ( PCOUNT => ( PCOUNT +Int 1 ) )
             </pc>
             <gas>
               ( GAVAIL => ( GAVAIL -Int Glow < SCHED > ) )
             </gas>
             ...
           </callState>
           ...
         </evm>
         ...
       </ethereum>
       ...
     </kevm>
  requires ( Glow < SCHED > <=Int GAVAIL )
   andBool ( #sizeWordStack( W0 /Word W1 : WS ) <=Int 1024 )
    [priority(40)]


// {OPTIMIZATIONS}


endmodule
```
